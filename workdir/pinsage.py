class PinSAGE(nn.Module):
    def __init__(self, in_feats, n_hidden, n_layers):
        super().__init__()

        self.W = nn.Linear(in_feats, n_hidden)
        self.layers = nn.ModuleList()
        for i in range(n_layers):
            self.layers.append(nn.Linear(n_hidden * 2, n_hidden))

    def forward(self, frontiers, X):
        """
        Parameters
        ----------
        frontiers : list[NodeFlowFrontier]
            Frontiers generated by a sampler
        x : KVStore
            Input feature KVStore
        """
        # initialization
        for i in range(len(frontiers)):
            # FIXME should pull from kvstore in practice
            x = X[induced_nodes]
            h = self.W(x)
            frontiers[i].ndata['h'] = h

        # convolution in the two-level nested loop fashion similar to GraphSAGE
        for i in range(len(frontiers)):
            for j in range(len(frontiers) - i):
                frontiers[i].update_all(fn.u_mul_e('h', 'weights', 'm'), fn.sum('m', 'h_agg'))
                frontiers[i].ndata['h_new'] = self.layers[j](
                        torch.cat([frontiers[i].ndata['h'], frontiers[i].ndata['h_new']], 1))
            for j in range(len(frontiers) - i - 1):
                frontiers[i].ndata['h'] = frontiers[i + 1].ndata['h_new']

        return frontiers[0].ndata['h']



class ModularPinSAGESampler(object):
    # TODO: this is supposed to be how users would call C PinSAGE neighbor sampler to
    # build their own
    pass


class BuiltinPinSAGESampler(object):
    """PinSAGE sampler that generates frontiers from a batch of seed nodes
    with type ``utype``.

    The graph must be a bidirectional bipartite graph, and only the nodes
    with type ``utype`` are sampled.

    The weights of the neighbors are stored as ``weights`` feature on the
    edges.
    """
    def __init__(
            self,
            HG,
            num_layers,
            num_neighbors,
            num_traces,
            restart_prob,
            max_trace_length,
            utype,
            vtype):
        self.HG = HG
        self.num_layers = num_layers
        self.num_neighbors = num_neighbors
        self.num_traces = num_traces
        self.restart_prob = restart_prob
        self.max_trace_length = max_trace_length
        self.utype = utype
        self.vtype = vtype
        self.fwtype = HG.get_etype_id(find_etype(HG, utype, vtype))
        self.bwtype = HG.get_etype_id(find_etype(HG, vtype, utype))
        self.metapath = [self.fwtype, self.bwtype]

    def __call__(self, seed_nodes):
        frontiers = _CAPI_DGLPinSageNeighborSampling(
                self.HG._graph,
                utils.toindex(self.metapath).todgltensor(),
                utils.toindex(seed_nodes).todgltensor(),
                self.num_neighbors,
                self.num_traces,
                self.restart_prob,
                self.max_trace_length,
                self.num_layers)
        return [NodeFlowFrontier._from_internal(self.HG, f) for f in frontiers]
