class PinSAGE(nn.Module):
    def __init__(self, in_feats, n_hidden, n_layers):
        super().__init__()

        self.W = nn.Linear(in_feats, n_hidden)
        self.layers = nn.ModuleList()
        for i in range(n_layers):
            self.layers.append(nn.Linear(n_hidden * 2, n_hidden))

    def forward(self, frontiers, X):
        """
        Parameters
        ----------
        frontiers : list[NodeFlowFrontier]
            Frontiers generated by a sampler
        x : KVStore
            Input feature KVStore
        """
        # initialization
        for i in range(len(frontiers)):
            # FIXME should pull from kvstore in practice
            x = X[induced_nodes]
            h = self.W(x)
            frontiers[i].ndata['h'] = h

        # convolution in the two-level nested loop fashion similar to GraphSAGE
        for i in range(len(frontiers)):
            for j in range(len(frontiers) - i):
                frontiers[i].update_all(fn.u_mul_e('h', 'weights', 'm'), fn.sum('m', 'h_agg'))
                frontiers[i].ndata['h_new'] = self.layers[j](
                        torch.cat([frontiers[i].ndata['h'], frontiers[i].ndata['h_new']], 1))
            for j in range(len(frontiers) - i - 1):
                frontiers[i].ndata['h'] = frontiers[i + 1].ndata['h_new']

        return frontiers[0].ndata['h']



class PinSAGESampling(object):
    def __init__(self, HG, etypes, num_neighbors, num_traces, restart_prob, max_trace_length):
        self.HG = HG
        self.etypes = etypes
        self.num_neighbors = num_neighbors
        self.num_traces = num_traces
        self.restart_prob = restart_prob
        self.max_trace_length = max_trace_length
        
    # TODO: this is supposed to be how users would call C PinSAGE neighbor sampler to
    # build their own
    def __call__(self, frontiers, seed_nodes):
        from collections import Counter

        if len(frontiers) > 0:
            seed_nodes = torch.unique(frontiers[-1])

        neighbors = []
        neighbor_weights = []
        ntype = self.HG.to_canonical_etype(self.etypes[0])[0]
        for seed in seed_nodes:
            counter = Counter()
            for _ in range(self.num_traces):
                curr = seed
                for hop in range(self.max_trace_length):
                    halt = False
                    for etype in self.etypes:
                        succ = self.HG.successors(curr, etype=etype)
                        if len(succ) == 0:
                            halt = True
                            break
                        curr = succ[torch.randint(len(succ))]

                    if halt or torch.rand() < self.restart_prob:
                        break
                    counter.update(curr.item())

            curr_neighbors, curr_neighbor_weights = zip(counter.most_common(self.num_neighbors))
            curr_neighbors = torch.LongTensor(curr_neighbors)
            curr_neighbor_weights = torch.FloatTensor(curr_neighbor_weights)
            curr_neighbor_weights /= curr_neighbor_weights.sum()
            neighbors.append(curr_neighbors)
            neighbor_weights.append(curr_neighbor_weights)

        dst = seed_nodes[:, None].expand(seed_nodes.shape[0], self.num_neighbors).flatten()
        src = neighbors.flatten()
        weights = neighbor_weights.flatten()
        new_frontier = dgl.graph((src, dst), card=self.HG.number_of_nodes(ntype))
        new_frontier.edata['weights'] = weights

        return new_frontier


class Sequential(object):
    def __init__(self, policies):
        self.policies = policies

    def __call__(self, seeds):
        frontiers = []
        for p in self.policies:
            frontiers.append(p(frontiers, seeds))
        return frontiers


# A pin's neighbor is another pin that shares the same board
metapath = [('pin', 'in', 'board'), ('board', 'contains', 'pin')]


class BuiltinPinSAGESampler(object):
    """PinSAGE sampler that generates frontiers from a batch of seed nodes
    with type ``utype``.

    The graph must be a bidirectional bipartite graph, and only the nodes
    with type ``utype`` are sampled.

    The weights of the neighbors are stored as ``weights`` feature on the
    edges.
    """
    def __init__(
            self,
            HG,
            num_layers,
            num_neighbors,
            num_traces,
            restart_prob,
            max_trace_length,
            utype,
            vtype):
        self.HG = HG
        self.num_layers = num_layers
        self.num_neighbors = num_neighbors
        self.num_traces = num_traces
        self.restart_prob = restart_prob
        self.max_trace_length = max_trace_length
        self.utype = utype
        self.vtype = vtype
        self.fwtype = HG.get_etype_id(find_etype(HG, utype, vtype))
        self.bwtype = HG.get_etype_id(find_etype(HG, vtype, utype))
        self.metapath = [self.fwtype, self.bwtype]

    def __call__(self, seed_nodes):
        frontiers = _CAPI_DGLPinSageNeighborSampling(
                self.HG._graph,
                utils.toindex(self.metapath).todgltensor(),
                utils.toindex(seed_nodes).todgltensor(),
                self.num_neighbors,
                self.num_traces,
                self.restart_prob,
                self.max_trace_length,
                self.num_layers)
        return [NodeFlowFrontier._from_internal(self.HG, f) for f in frontiers]

# Sampler iterator that keeps generating pin-pin minibatch graph from a pin-board
# bipartite graph ``HG``.
# Note that PinSAGE is equivalent to GraphSAGE except that the neighborhoods
# are different.  If we use uniform sampling then the model becomes vanilla GraphSAGE
def sampler_iter(seed_nodes, **kwargs):
    sampler = BuiltinPinSAGESampler(**kwargs)
    #sampler = Sequential(
    #        PinSAGESampling(HG, metapath, 10, 10, 0.5, 3),
    #        PinSAGESampling(HG, metapath, 10, 10, 0.5, 3))

    while True:
        seed_batches = seed_nodes.split(BATCH_SIZE)
        for batch in seed_batches:
            yield sampler(seed_batches)

it = sampler_iter(SEEDS, HG=HG, num_layers=2, num_neighbors=5, num_random_walks=10,
                  restart_prob=0.5, max_trace_length=5, utype='pin', vtype='board')
model = PinSAGE(20, 10, 2)
opt = torch.optim.Adam(model.parameters())
for frontier in it:
    output = model(frontiers, X)
    loss = compute_loss(output)
    opt.zero_grad()
    loss.backward()
    opt.step()
