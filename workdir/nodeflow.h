namespace dgl {

namespace sampling {

struct NodeFlowFrontier : public runtime::Object {
  /*! \brief The graph.  Node ID space is the same as parent graph. */
  HeteroGraphPtr graph;
  /*!
   * \brief The induced node ids, indexed by node type in \c graph.
   * \note This is also a map from the new node id to the node id in the parent graph.
   * \note This would be reflected as the Python attribute \c induced_nodes
   */
  List<IdArray> induced_nodes;
  /*!
   * \brief The induced edge ids, indexed by edge type in \c graph.
   * \note This is also a map from the new edge id to the edge id in the parent graph.
   * \note This would be reflected as the Python attribute \c induced_edges
   */
  List<IdArray> induced_edges;
  /*!
   * \brief Any additional node data generated by sampler, indexed by node type in \c
   * graph.
   * \note This would be merged into the node frame.
   */
  // ndata[ntype][name][nid]
  List<Map<std::string, runtime::NDArray>> ndata;
  /*!
   * \brief Any additional edge data generated by sampler, indexed by edge type in \a
   * graph.
   * \note This would be merged into the edge frame.
   */
  // edata[etype][name][eid]
  List<Map<std::string, runtime::NDArray>> edata;
  /*!
   * \brief Any additional graph-level data generated by sampler.
   * \note Each entry would be reflected as an attribute, with its key as attribute name,
   * and value converted into a framework-specific tensor object.
   */
  // gdata[name]
  Map<std::string, runtime::NDArray>> gdata;

  static constexpr const char* _type_key = "sampler.NodeFlowFrontier";
  DGL_DECLARE_OBJECT_TYPE_INFO(NodeFlowFrontier, runtime::Object);

  void VisitAttrs(runtime::AttrVisitor *v) final {
    v->Visit("graph", &graph);
    v->Visit("induced_nodes", &induced_nodes);
    v->Visit("induced_edges", &induced_edges);
    v->Visit("ndata", &ndata);
    v->Visit("edata", &edata);
    v->Visit("gdata", &gdata);
  }
};
typedef std::shared_ptr<NodeFlowFrontier> NodeFlowFrontierPtr;
DGL_DEFINE_OBJECT_REF(NodeFlowFrontierRef, NodeFlowFrontier);

};  // namespace sampling

};  // namespace dgl
